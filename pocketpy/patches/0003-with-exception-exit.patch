diff --git a/pocketpy/vendor/pocketpy.c b/pocketpy/vendor/pocketpy.c
--- a/pocketpy/vendor/pocketpy.c
+++ b/pocketpy/vendor/pocketpy.c
@@ -1913,6 +1913,8 @@ OPCODE(ADD_CLASS_ANNOTATION)
 /**************************/
 OPCODE(WITH_ENTER)
 OPCODE(WITH_EXIT)
+// ucharm patch: WITH_EXIT_EXC opcode for exception-aware __exit__
+OPCODE(WITH_EXIT_EXC)
 /**************************/
 OPCODE(BEGIN_TRY)
 OPCODE(END_TRY)
@@ -5011,6 +5014,24 @@ __NEXT_STEP:
             POP();
             DISPATCH();
         }
+        // ucharm patch: ensure __exit__ runs on exceptions and can suppress
+        case OP_WITH_EXIT_EXC: {
+            // [expr] -> [suppress]
+            FrameExcInfo* info = Frame__top_exc_info(frame);
+            assert(info != NULL && !py_isnil(&info->exc));
+            py_push(TOP());
+            if(!py_pushmethod(__exit__)) {
+                TypeError("'%t' object does not support the context manager protocol", TOP()->type);
+                goto __ERROR;
+            }
+            py_push(&info->exc);
+            if(!py_vectorcall(1, 0)) goto __ERROR;
+            int suppress = py_bool(py_retval());
+            if(suppress < 0) goto __ERROR;
+            POP();
+            py_newbool(SP()++, suppress != 0);
+            DISPATCH();
+        }
         ///////////
         case OP_BEGIN_TRY: {
             Frame__begin_try(frame, SP());
@@ -10331,6 +10352,8 @@ OPCODE(ADD_CLASS_ANNOTATION)
 /**************************/
 OPCODE(WITH_ENTER)
 OPCODE(WITH_EXIT)
+// ucharm patch: WITH_EXIT_EXC opcode for exception-aware __exit__
+OPCODE(WITH_EXIT_EXC)
 /**************************/
 OPCODE(BEGIN_TRY)
 OPCODE(END_TRY)
@@ -27080,8 +27136,31 @@ static Error* compile_stmt(Compiler* self) {
                 // discard `__enter__()`'s return value
                 Ctx__emit_(ctx(), OP_POP_TOP, BC_NOARG, BC_KEEPLINE);
             }
+            // ucharm patch: compile 'with' to call __exit__ on exceptions (and allow suppression)
+            Ctx__enter_block(ctx(), CodeBlockType_TRY);
+            Ctx__emit_(ctx(), OP_BEGIN_TRY, BC_NOARG, prev()->line);
             check(compile_block_body(self));
+            Ctx__emit_(ctx(), OP_END_TRY, BC_NOARG, BC_KEEPLINE);
             Ctx__emit_(ctx(), OP_WITH_EXIT, BC_NOARG, prev()->line);
+            int patch_normal = Ctx__emit_(ctx(), OP_JUMP_FORWARD, BC_NOARG, BC_KEEPLINE);
+            Ctx__exit_block(ctx());
+
+            // except:
+            Ctx__emit_(ctx(), OP_LOAD_TRUE, BC_NOARG, BC_KEEPLINE);
+            int patch_no_match = Ctx__emit_(ctx(), OP_POP_JUMP_IF_FALSE, BC_NOARG, BC_KEEPLINE);
+            Ctx__emit_(ctx(), OP_HANDLE_EXCEPTION, BC_NOARG, BC_KEEPLINE);
+            Ctx__emit_(ctx(), OP_WITH_EXIT_EXC, BC_NOARG, BC_KEEPLINE);
+            int patch_reraise = Ctx__emit_(ctx(), OP_POP_JUMP_IF_FALSE, BC_NOARG, BC_KEEPLINE);
+            Ctx__emit_(ctx(), OP_END_TRY, BC_NOARG, BC_KEEPLINE);
+            int patch_handled = Ctx__emit_(ctx(), OP_JUMP_FORWARD, BC_NOARG, BC_KEEPLINE);
+
+            // re-raise
+            Ctx__patch_jump(ctx(), patch_reraise);
+            Ctx__patch_jump(ctx(), patch_no_match);
+            Ctx__emit_(ctx(), OP_RE_RAISE, BC_NOARG, BC_KEEPLINE);
+
+            Ctx__patch_jump(ctx(), patch_normal);
+            Ctx__patch_jump(ctx(), patch_handled);
             Ctx__exit_block(ctx());
         } break;
         /*************************************************/
