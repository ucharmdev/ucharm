#!/usr/bin/env python3
"""
microcharm bundle tool

Bundles a MicroPython script with the microcharm library into a single executable.

Usage:
    python bundle.py myapp.py -o myapp
    ./myapp
"""

import argparse
import os
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent
MICROCHARM_DIR = SCRIPT_DIR.parent / "microcharm"


def find_micropython():
    """Find micropython binary."""
    # Check common locations
    locations = [
        shutil.which("micropython"),
        "/opt/homebrew/bin/micropython",
        "/usr/local/bin/micropython",
        "/usr/bin/micropython",
    ]
    for loc in locations:
        if loc and os.path.exists(loc):
            return loc
    return None


def create_bundle_script(main_script, output_path, include_paths=None):
    """
    Create a self-extracting bundle.

    This creates a shell script that:
    1. Extracts embedded Python files to a temp directory
    2. Runs micropython with the correct path
    """
    include_paths = include_paths or []

    # Read all files to embed
    files_to_embed = {}

    # Embed microcharm library
    for py_file in MICROCHARM_DIR.glob("*.py"):
        rel_path = f"microcharm/{py_file.name}"
        files_to_embed[rel_path] = py_file.read_text()

    # Embed main script
    main_content = Path(main_script).read_text()
    files_to_embed["__main__.py"] = main_content

    # Embed any additional includes
    for inc_path in include_paths:
        inc = Path(inc_path)
        if inc.is_file():
            files_to_embed[inc.name] = inc.read_text()
        elif inc.is_dir():
            for f in inc.rglob("*.py"):
                rel = f.relative_to(inc.parent)
                files_to_embed[str(rel)] = f.read_text()

    # Create the bundle
    import base64
    import json

    bundle_data = base64.b64encode(json.dumps(files_to_embed).encode()).decode()

    shell_script = f"""#!/bin/bash
# microcharm bundled application
# Generated by microcharm bundle tool

BUNDLE_DATA='{bundle_data}'

# Create temp directory
TMPDIR=$(mktemp -d)
trap "rm -rf $TMPDIR" EXIT

# Extract files
python3 -c "
import base64, json, os
data = json.loads(base64.b64decode('$BUNDLE_DATA'))
for path, content in data.items():
    full_path = '$TMPDIR/' + path
    os.makedirs(os.path.dirname(full_path) if os.path.dirname(full_path) else '$TMPDIR', exist_ok=True)
    with open(full_path, 'w') as f:
        f.write(content)
"

# Run with micropython
exec micropython "$TMPDIR/__main__.py" "$@"
"""

    with open(output_path, "w") as f:
        f.write(shell_script)

    os.chmod(output_path, 0o755)
    print(f"Created bundle: {output_path}")


def create_frozen_manifest(main_script, output_dir, include_paths=None):
    """
    Create a manifest for building frozen micropython.

    This is for creating a true single binary by rebuilding micropython
    with your code frozen in.
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    manifest_lines = ["# Frozen manifest for microcharm app", 'freeze(".", (']

    # Copy microcharm
    mc_out = output_dir / "microcharm"
    mc_out.mkdir(exist_ok=True)
    for py_file in MICROCHARM_DIR.glob("*.py"):
        shutil.copy(py_file, mc_out / py_file.name)
        manifest_lines.append(f'    "microcharm/{py_file.name}",')

    # Copy main script as __main__.py
    shutil.copy(main_script, output_dir / "__main__.py")
    manifest_lines.append('    "__main__.py",')

    manifest_lines.append("))")

    # Write manifest
    manifest_path = output_dir / "manifest.py"
    manifest_path.write_text("\n".join(manifest_lines))

    print(f"Created frozen manifest in: {output_dir}")
    print(f"To build, run micropython with FROZEN_MANIFEST={manifest_path}")


def create_single_file(main_script, output_path, include_paths=None):
    """
    Create a single .py file with microcharm embedded.

    This bundles everything into one file that can be run with:
        micropython bundled_app.py
    """
    include_paths = include_paths or []

    parts = [
        "#!/usr/bin/env micropython",
        "# Bundled microcharm application",
        "# Run with: micropython " + str(output_path),
        "",
        "import sys",
        "import time",
        "",
        "# === Embedded microcharm library ===",
        "",
    ]

    # Embed microcharm modules (without __init__.py imports)
    # Order matters - terminal first, then style, then components, then input, then table
    module_order = ["terminal", "style", "components", "input", "table"]

    for module_name in module_order:
        py_file = MICROCHARM_DIR / f"{module_name}.py"
        if not py_file.exists():
            continue
        content = py_file.read_text()
        parts.append(f"# --- microcharm/{py_file.name} ---")

        # Process content to handle imports
        lines = content.split("\n")
        processed = []
        for line in lines:
            # Skip relative imports (we'll inline everything)
            if line.strip().startswith("from ."):
                continue
            # Skip duplicate stdlib imports
            if line.strip() in ("import sys", "import time"):
                continue
            processed.append(line)
        parts.extend(processed)
        parts.append("")

    # Add main script
    parts.append("# === Main application ===")
    parts.append("")
    main_content = Path(main_script).read_text()

    # Process main script imports
    lines = main_content.split("\n")
    in_multiline_import = False

    for line in lines:
        stripped = line.strip()

        # Handle multiline imports
        if in_multiline_import:
            if ")" in line:
                in_multiline_import = False
            continue

        # Skip microcharm imports
        if "from microcharm" in line or "import microcharm" in line:
            if "(" in line and ")" not in line:
                in_multiline_import = True
            continue

        # Skip sys.path manipulation
        if "sys.path" in line:
            continue

        # Skip duplicate imports
        if stripped in ("import sys", "import time"):
            continue

        parts.append(line)

    Path(output_path).write_text("\n".join(parts))
    os.chmod(output_path, 0o755)
    print(f"Created single-file bundle: {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Bundle MicroPython scripts with microcharm"
    )
    parser.add_argument("script", help="Main Python script to bundle")
    parser.add_argument("-o", "--output", required=True, help="Output file path")
    parser.add_argument(
        "-I",
        "--include",
        action="append",
        default=[],
        help="Additional files/directories to include",
    )
    parser.add_argument(
        "--mode",
        choices=["shell", "frozen", "single"],
        default="shell",
        help="Bundle mode: shell (default), frozen, or single",
    )

    args = parser.parse_args()

    if not os.path.exists(args.script):
        print(f"Error: Script not found: {args.script}")
        sys.exit(1)

    mpy = find_micropython()
    if not mpy:
        print("Warning: micropython not found in PATH")

    if args.mode == "shell":
        create_bundle_script(args.script, args.output, args.include)
    elif args.mode == "frozen":
        create_frozen_manifest(args.script, args.output, args.include)
    elif args.mode == "single":
        create_single_file(args.script, args.output, args.include)


if __name__ == "__main__":
    main()
